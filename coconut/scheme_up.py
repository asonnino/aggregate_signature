"""
Coconut threshold credentials scheme, with unconditional privacy.

"""
from bplib.bp import BpGroup, G2Elem
from coconut.utils import *
from coconut.proofs import *


def setup(q=1):
    """
    Generate the public parameters.

    Parameters:
        - `q` (integer): the maximum number of attributes that can be embbed in the credentials

    Returns:
        - params: the publc parameters
    """
    coco_ensure(q > 0, "Number of authorities must be positive.")
    G = BpGroup()
    (g1, g2) = G.gen1(), G.gen2()
    hs = [G.hashG1(("h%s" % i).encode("utf8")) for i in range(q)]
    h_blind = G.hashG1(("h_blind").encode("utf8"))
    (e, o) = G.pair, G.order()
    return (G, o, g1, hs, h_blind, g2, e)


def ttp_keygen(params, t, n):
    """
        Generate keys for threshold credentials (executed by a TTP). This protocol can however be executed in a distributed way as illustrated by the following link: https://crysp.uwaterloo.ca/software/DKG/

    Parameters:
        - `params`: public parameters generated by `setup`
        - `t` (integer): the threshold parameter
        - `n` (integer): the total number of authorities

    Returns:
        - `sk` [(Bn, [Bn])]: array containing the secret key of each authority
        - `vk` [(G2Elem, G2Elem, [G2Elem])]: array containing the verification key of each authority
    """
    (G, o, g1, hs, h_blind, g2, e) = params
    q = len(hs)
    coco_ensure(n >= t and t > 0 and q > 0, "Wrong thresholds.")
    # generate polynomials
    v = [o.random() for _ in range(0,t)]
    w = [[o.random() for _ in range(0,t)] for _ in range(q)]
    # generate shares
    x = [poly_eval(v,i) % o for i in range(1,n+1)]
    y = [[poly_eval(wj,i) % o for wj in w] for i in range(1,n+1)]
    # set keys
    sk = list(zip(x, y))
    vk = [(g2, x[i]*g2, [y[i][j]*g2 for j in range(len(y[i]))]) for i in range(len(sk))]
    return (sk, vk)


def keygen(params):
    """
        Generate the secret and verification keys for an authority. This protocol cannot be used for threshold setting.

        Parameters:
        - `params`: public parameters generated by `setup`

        Returns:
        - `sk` (Bn, [Bn]): secret key of the authority
        - `vk` (G2Elem, G2Elem, [G2Elem]): verification key of the authority
    """
    (G, o, g1, hs, h_blind, g2, e) = params
    q = len(hs)
    x = o.random()
    y = [o.random() for _ in range(q)]
    sk = (x, y)
    vk = (g2, x*g2, [yi*g2 for yi in y], [yi*h_blind for yi in y])
    return (sk, vk)


def agg_key(params, vks, threshold=True):
    """
    Aggregate the verification keys.

    Parameters:
        - `params`: public parameters generated by `setup`
        - `vks` [(G2Elem, G2Elem, [G2Elem])]: array containing the verification key of each authority
        - `threshold` (bool): optional, whether to use threshold cryptography or not

    Returns:
        - `aggr_vk`: aggregated verification key
    """
    (G, o, g1, hs, h_blind, g2, e) = params
    # filter missing keys (in the threshold setting)
    filter = [vks[i] for i in range(len(vks)) if vks[i] is not None]
    indexes = [i+1 for i in range(len(vks)) if vks[i] is not None]
    # evaluate all lagrange basis polynomials
    l = lagrange_basis(indexes,o) if threshold else [1 for _ in range(len(vks))]
    # aggregate keys
    (_, alpha, beta, h_blind_yis) = zip(*filter)
    q = len(beta[0])
    aggr_alpha = ec_sum([l[i]*alpha[i] for i in range(len(filter))])
    aggr_beta = [ec_sum([l[i]*beta[i][j] for i in range(len(filter))]) for j in range(q)]
    aggr_h_blind_yis = [ec_sum([l[i]*h_blind_yis[i][j] for i in range(len(filter))]) for j in range(q)]
    aggr_vk = (g2, aggr_alpha, aggr_beta, aggr_h_blind_yis)
    return aggr_vk


def prepare_blind_sign(params, private_m, public_m=[]):
    """
    Build cryptographic material for blind sign.

    Parameters:
        - `params`: public parameters generated by `setup`
        - `private_m` [Bn]: array containing the private attributes
        - `public_m` [Bn]: optional, array containing the public attributes

    Returns:
        - `Ls`: the blinding factors used for issuing
        - `Lambda`: commitments and encryptions to the attributes
    """
    coco_ensure(len(private_m) > 0, "Need some private messages.")
    (G, o, g1, hs, h_blind, g2, e) = params
    attributes = private_m + public_m
    coco_ensure(len(attributes) <= len(hs), "Too many attributes.")
    # build commitment
    r = o.random()
    Ls = [o.random() for m in private_m]
    cm = r*g1 + ec_sum([attributes[i]*hs[i] for i in range(len(attributes))])
    # build Pedersen Commit
    h = G.hashG1(cm.export())
    c = [m*h+L*h_blind for (L, m) in zip(Ls, private_m)]
    # build proofs
    pi_s = make_pi_s_up(params, Ls, c, cm, r, public_m, private_m)
    Lambda = (cm, c, pi_s)
    return (Ls, Lambda)


def blind_sign(params, sk, Lambda, public_m=[]):
    """
    Blindly sign private attributes.

    Parameters:
        - `params`: public parameters generated by `setup`
        - `sk` (Bn, Bn): the secret key of the authority
        - `Lambda`: commitments and encryptions to the attributes
        - `public_m` [Bn]: optional, array containing the public attributes

    Returns:
        - `sigma_tilde`: blinded credential
    """
    (G, o, g1, hs, h_blind, g2, e) = params
    (x, y) = sk
    (cm, c, pi_s) = Lambda
    # (a, b) = zip(*c)
    coco_ensure( (len(c)+len(public_m)) <= len(hs), "Too many attributes.")
    # verify proof of correctness
    coco_ensure(verify_pi_s_up(params, c, cm, pi_s), "User ZKProof failed.")
    # issue signature
    h = G.hashG1(cm.export())
    t1 = [mi*h for mi in public_m]
    t = x*h + ec_sum([yi*ci for yi,ci in zip(y,c+t1)])
    sigma_tilde = (h, t)
    return sigma_tilde


def agg_cred(params, aggr_vk, sigs, Ls, threshold=True):
    """
    Aggregate partial credentials.

    Parameters:
        - `params`: public parameters generated by `setup`
        - `sigs` [(G1Elem, G1Elem)]: array of ordered partial credentials, include `None` if a partial credential is missing (in the threshold setting)
        - `Ls` [Bn]: the blinding factors used for issuing
        - `threshold` (bool): optional, whether to use threshold cryptography or not

    Returns:
        - `aggr_sigma`: aggregated credential
    """
    (G, o, g1, hs, h_blind, g2, e) = params
    (g2, alpha, beta, h_blind_yi) = aggr_vk

    # filter missing credentials (in the threshold setting)
    filter = [sigs[i] for i in range(len(sigs)) if sigs[i] is not None]
    indexes = [i+1 for i in range(len(sigs)) if sigs[i] is not None]
    # evaluate all lagrange basis polynomials
    l = lagrange_basis(indexes,o) if threshold else [1 for _ in range(len(sigs))]
    # aggregate sigature
    (h, s) = zip(*filter)
    aggr_s_raw = ec_sum([l[i]*s[i] for i in range(len(filter))])

    # unblind
    blinder = ec_sum([L*h_blind_yi[i] for i, L in enumerate(Ls)])
    aggr_s = aggr_s_raw - blinder

    aggr_sigma = (h[0], aggr_s)
    return aggr_sigma
